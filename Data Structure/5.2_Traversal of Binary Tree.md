mpChapter 5: Tree
# 5.2 Traversal in Binary Tree｜二叉树的遍历
## 5.2.1 Preorder Traversal｜先序遍历
1. 递归算法
```C
// Define the Binary Tree | 定义二叉树
typedef struct BiTNode {
    Elemtype data;                      // 数据域
    struct BiTNode *lchild, *rchild;    // 左右孩子指针
} BiTNode, *BiTree;

// Establish the Preorder | 建立先序访问函数
void preOrder(BiTree T) 
{
    if(T != NULL) {
        visit(T);
        preOrder(T->lchild);
        preOrder(T->rchild);
    }
}

// S(n)=O(h+1), h=hightOfTree;
```
2. 非递归算法

```C
void preOrder(BiTree T) 
{
    InitStack(S);               // 初始化栈S
    BiTree p = T;               // 定义p为遍历指针

    // 循环条件是 p 不空或栈不空
    while(p || !isEmpty(S)) { 

        // 遍历左子树  
        if(p) {                 
            visit(p);           // 访问出栈结点
            Push(S, p);         // 当前结点入栈
            p=p->lchild;        // 左孩子不空一直左走
        } 
        
        // 出栈，并转向出栈结点的右子树
        else {                
            Pop(S, p);          // 栈顶元素出栈
            p = p->rchild;      // 向右子树前进，p指针被赋值当前结点的右孩子
        }
    }
}
```
## 5.2.2 Inorder Traversal｜中序遍历
1. 递归算法
```C
// Define the Binary Tree | 定义二叉树
typedef struct BiTNode {
    Elemtype data;                      // 数据域
    struct BiTNode *lchild, *rchild;    // 左右孩子指针
} BiTNode, *BiTree;

// Establish the Inorder | 建立中序遍历
void inOrder(BiTree T) 
{
    if(T != NULL) {
        inOrder(T->lchild);
        visit(T);
        inOrder(T->rchild);
    }
}
```
2. 非递归算法

```C
void InitStack();
void Push();
void Pop();
void isEmpty(Stack S);

void inOrder(BiTree T)
{
    InitStack(S);               // 初始化栈S
    BiTree p = T;               // 定义p为遍历指针

    // 循环条件是 p 不空或栈不空
    while(p || !isEmpty(S)) {   

        // 遍历左子树
        if(p) {                 
            Push(S, p);         // 当前结点入栈
            p=p->lchild;        // 左孩子不空一直左走
        } 
        
        // 出栈，并转向出栈结点的右子树
        else {                
            Pop(S, p);          // 栈顶元素出栈
            visit(p);           // 访问出栈结点
            p = p->rchild;      // 向右子树前进，p指针被赋值当前结点的右孩子
        }
    }
}
```
## 5.2.3 Postorder Traversal｜后序遍历

1. 递归算法

```C
// Define the Binary Tree | 定义二叉树
typedef struct BiTNode {
    Elemtype data;                      // 数据域
    struct BiTNode *lchild, *rchild;    // 左右孩子指针
} BiTNode, *BiTree;

// Establish the Postorder | 建立后序遍历
void postOrder(BiTree T) 
{
    if(T != NULL) {
        postOrder(T->lchild);
        postOrder(T->rchild);
        visit(T);
    }
}
```

2. 非递归算法

```C
void postOrder(BiTree T)
{
    InitStack(S);               // 初始化栈S
    BiTree p = T;               // 定义p为遍历指针
    
    // 循环条件是 p 不空或栈不空
    while(p || !isEmpty(S)) {   
        
        // 遍历左子树
        if(p) {                 
            Push(S, p);         // 当前结点入栈
            p=p->lchild;        // 左孩子不空一直左走
        } 

        // 出栈，并转向出栈结点的右子树
        else {                
            getTop(S, p);       // 读栈顶结点（非出栈）

            // 若右子树存在且未被访问过
            if(p->rchild && p->rchild != r) {   
                p=p->rchild;    // 转向右
            } 

            // 否则，执行弹出结点（出栈），并访问该结点
            else {            
                Pop(S, p);      // 栈顶元素出栈
                visit(p->data); // 访问出栈结点
                r=p;            // 记录最近访问过的节点
                p = p->rchild;  // 向右子树前进，p指针被赋值当前结点的右孩子
            }
        }
    }
}
```

## 5.2.4 Sequential traversal | 层序遍历
