## å•é“¾è¡¨/LinkList
### 1. å®šä¹‰
#### 1.1 ä½¿ç”¨ä»£ç å®šä¹‰ä¸€ä¸ªå•é“¾è¡¨
```C
struct LNode            //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
{
  ElemType data;        //æ¯ä¸ªç»“ç‚¹å­˜æ”¾ä¸€ä¸ªæ•°æ®å…ƒç´ 
  struct LNode *next;   //æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
};

//å¢åŠ ä¸€ä¸ªæ–°çš„ç»“ç‚¹ï¼šåœ¨å†…å­˜ä¸­ç”³è¯·ä¸€ä¸ªç»“ç‚¹æ‰€éœ€çš„ç©ºé—´ï¼Œå¹¶ç”¨æŒ‡é’ˆ P æŒ‡å‘è¿™ä¸ªç»“ç‚¹
struct LNode *p=(struct LNode *)malloc(sizeof(struct LNode));

//typedef å…³é”®å­—--æ•°æ®ç±»å‹é‡å‘½å
typedef<ElemType><para>

/*
e.g:
typedef int zhengshu;
typedef int *zhengshuzhizhen;
int x = 1;  <==>  zhengshu x = 1;
int *p;     <==>  zhengshuzhizhen p;
*/
```
ä»¥ä¸‹ä¸¤æ®µä»£ç è¡¨ç¤ºçš„æ„æ€ä¸€è‡´ğŸ‘‡

```C

//1
struct LNode                                                      
{
  ElemType data;                                                  
  struct LNode *next;   
};
typedef struct LNode LNode;
typedef struct LNode *LinkList;

//2
typedef struct LNode
{
  ElemType data;
  struct Lnode *next;
}Lnode, *LinkList;
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

ğŸŒ°

```C

typedef struct LNode        //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
{
  ElemType data;            //æ¯ä¸ªç»“ç‚¹å­˜æ”¾ä¸€ä¸ªæ•°æ®å…ƒç´ 
  struct LNode *next;       //å®šä¹‰æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
}Lnode, *LinkList;

Lnode *GetElem(LinkList l, int i)   
//è¯­å¥å¼€å§‹ä½¿ç”¨ LNode * è¡¨ç¤ºå¢™æ•²è¿”å›çš„æ˜¯ä¸€ä¸ªç»“ç‚¹ï¼ŒæŒ‰ä½æŸ¥æ‰¾è¯­å¥ä½¿ç”¨ LinkList è¡¨ç¤ºå¼ºè°ƒè¿™æ˜¯ä¸€ä¸ªå•é“¾è¡¨
{
  int j=1;
  LNode *p=L->next;
  if(i==0)
  {
    return L;
  }
  else if(i<1)
  {
    return NULL;
  }
  while(p!=NULL && j<1)
  {
    p=p->next;
    j++;
  }
  return p;
}
```

#### 1.2 ä¸å¸¦å¤´èŠ‚ç‚¹çš„å•é“¾è¡¨
```C
typedef struct LNode        //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
{
  ElemType data;            //æ¯ä¸ªç»“ç‚¹å­˜æ”¾ä¸€ä¸ªæ•°æ®å…ƒç´ 
  struct LNode *next;       //å®šä¹‰æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
}Lnode, *LinkList;

//åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„å•é“¾è¡¨
bool InitList(LinkList &L)
{
  L=NULL;
  return true;
}

void test()
{
  LinkList L;               //å£°æ˜ä¸€ä¸ªæŒ‡å‘å•é“¾è¡¨çš„æŒ‡é’ˆ
  
  InitList(L);              //åˆå§‹åŒ–ä¸€ä¸ªç©ºè¡¨
  //Â·Â·Â·åç»­ä»£ç Â·Â·Â·
}

bool Empty(LinkList L)      //åˆ¤ç©ºæ“ä½œ
{
  if(L == NULL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

//or

bool Empty(LinkList L)
{
  return (L == NULL);
}
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

#### 1.3 å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨
```C
typedef struct LNode        //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
{
  ElemType data;            //æ¯ä¸ªç»“ç‚¹å­˜æ”¾ä¸€ä¸ªæ•°æ®å…ƒç´ 
  struct LNode *next;       //å®šä¹‰æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
}Lnode, *LinkList;

//åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„å•é“¾è¡¨ï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
bool InitList(LinkList &L)
{
  L = (LNode *)malloc(sizeof(LNode));     //ç”³è¯·ä¸€ç‰‡ç©ºé—´ç»™åˆ°å¤´ç»“ç‚¹
  if(L == NULL)
  {
    return false;                         //å†…å­˜ä¸è¶³ï¼Œåˆ†é…å¤±è´¥çš„è¯­å¥
  }
  L->next=NULL;                           //å¤´ç»“ç‚¹ä¹‹åæš‚æ—¶æ— ç»“ç‚¹
  return true;
}

void test()
{
  LinkList L;               //å£°æ˜ä¸€ä¸ªæŒ‡å‘å•é“¾è¡¨çš„æŒ‡é’ˆ
  InitList(L);              //åˆå§‹åŒ–ä¸€ä¸ªç©ºè¡¨
  //Â·Â·Â·åç»­ä»£ç Â·Â·Â·
}

bool Empty(LinkList L)      //åˆ¤ç©ºæ“ä½œ
{
  if(L -> next == NULL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

//or

bool Empty(LinkList L)
{
  return (L == NULL);
}
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

### 2. æ’å…¥
#### 2.1 æŒ‰ä½åºæ’å…¥ï¼ˆå¸¦å¤´èŠ‚ç‚¹ï¼‰
```C
//åœ¨ç¬¬ i ä¸ªä½ç½®æ’å…¥å…ƒç´  e ï¼ˆå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ï¼‰
bool ListInsert(LinkList &L, int i, ElemType e)
{
  if(i<1)
  {
    return false;
  }
  LNode *p;       //æŒ‡é’ˆpæŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=0;        //å½“å‰pæŒ‡å‘çš„ç»“ç‚¹ä½ç½®
  p = L;          //LæŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼ˆä¸å­˜æ•°æ®ï¼‰
  while(p!=NULL && j<i-1)   //åˆ©ç”¨å¾ªç¯æ‰¾åˆ°æ‰€æŒ‡å®šçš„ç»“ç‚¹ï¼ˆi-1ï¼‰
  {
    p=p->next;
    j++;
  }
  if(p==NULL)    //å½“iå€¼ä¸åˆæ³•ç¨‹åºè¿”å›é”™è¯¯
  {
    return false;
  }
  LNode *s = (LNode *)malloc(sizeof(LNode));
  s->data = e;
  s->next = p->next;  //ä¸å¯å’Œä¸‹é¢äº¤æ¢ï¼
  p->next = s;        //å°†ç»“ç‚¹sè¿æ¥åˆ°pä¹‹å
  return true;
}

typedef struct LNode
{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

#### 2.2 æŒ‰ä½åºæ’å…¥ï¼ˆä¸å¸¦å¤´èŠ‚ç‚¹ï¼‰
```C
bool ListInsert(LinkList &L, int i, ElemType e)
{
  if(i<1)
  {
    return false;
  }
  
  //ä¸å¸¦å¤´ç»“ç‚¹éœ€è¦åŠ å…¥ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶è¯­å¥
  if(i==1)
  {
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = L;
    L=s;
    return true;
  }
  LNode *p;       //æŒ‡é’ˆpæŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=1;        //å½“å‰pæŒ‡å‘çš„ç»“ç‚¹ä½ç½®
  p = L;          //LæŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼ˆä¸å­˜æ•°æ®ï¼‰
  while(p!=NULL && j<i-1)   //åˆ©ç”¨å¾ªç¯æ‰¾åˆ°æ‰€æŒ‡å®šçš„ç»“ç‚¹ï¼ˆi-1ï¼‰
  {
    p=p->next;
    j++;
  }
  if(p==NULL)    //å½“iå€¼ä¸åˆæ³•ç¨‹åºè¿”å›é”™è¯¯
  {
    return false;
  }
  LNode *s = (LNode *)malloc(sizeof(LNode));
  s->data = e;
  s->next = p->next;  //ä¸å¯å’Œä¸‹é¢äº¤æ¢ï¼
  p->next = s;        //å°†ç»“ç‚¹sè¿æ¥åˆ°pä¹‹å
  return true;
}

typedef struct LNode
{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

#### 2.3 æŒ‡å®šç»“ç‚¹çš„åæ’æ“ä½œ
åŸºç¡€ç‰ˆæœ¬
```C
//åæ’æ“ä½œï¼šåœ¨ p ç»“ç‚¹ä¹‹åæ’å…¥å…ƒç´  e
bool InsertNextNode(LNode *p, ElemType e)
{
  if(p==NULL)
  {
    return false;     //ç©ºæŒ‡é’ˆæç¤ºé”™è¯¯
  }
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if(s==NULL)         //å†…å­˜åˆ†é…å¤±è´¥è¿”å›æç¤ºé”™è¯¯
  {
    return false;
  }
  s->data = e;
  s->next = p ->next;
  p->next = s;
  return true;
}

typedef struct LNode
{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

è¿›é˜¶ç‰ˆæœ¬ï¼ˆè°ƒç”¨å‡½æ•°ï¼‰
```C
bool InsertNextNode(LNode *p, ElemType e);   //å£°æ˜ InsertNextNode

//åœ¨ç¬¬ i ä¸ªä½ç½®æ’å…¥å…ƒç´  e ï¼ˆå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ï¼‰
bool ListInsert(LinkList &L, int i, ElemType e)
{
  if(i<1)
  {
    return false;
  }
  LNode *p;       //æŒ‡é’ˆpæŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=0;        //å½“å‰pæŒ‡å‘çš„ç»“ç‚¹ä½ç½®
  p = L;          //LæŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼ˆä¸å­˜æ•°æ®ï¼‰
  while(p!=NULL && j<i-1)   //åˆ©ç”¨å¾ªç¯æ‰¾åˆ°æ‰€æŒ‡å®šçš„ç»“ç‚¹ï¼ˆi-1ï¼‰
  {
    p=p->next;
    j++;
  }
 return InsertNextNode(p,e);    //è°ƒç”¨ InsertNextNode å‡½æ•°
}

typedef struct LNode
{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;

//åæ’æ“ä½œï¼šåœ¨ p ç»“ç‚¹ä¹‹åæ’å…¥å…ƒç´  e
bool InsertNextNode(LNode *p, ElemType e)   //ç»™å‡º InsertNextNode å‡½æ•°çš„è¯­å¥å—
{
  if(p==NULL)
  {
    return false;     //ç©ºæŒ‡é’ˆæç¤ºé”™è¯¯
  }
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if(s==NULL)         //å†…å­˜åˆ†é…å¤±è´¥è¿”å›æç¤ºé”™è¯¯
  {
    return false;
  }
  s->data = e;
  s->next = p ->next;
  p->next = s;
  return true;
}
```
ä»¥ä¸Šæ“ä½œï¼Œè¢«ç§°ä½œâ€œå°è£…â€ğŸ“¦

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

#### 2.4 æŒ‡å®šç»“ç‚¹çš„å‰æ’æ“ä½œ
ç‰ˆæœ¬ä¸€ï¼ˆç½‘è¯¾ï¼‰
```C
//å‰æ’æ“ä½œï¼šåœ¨ p ç»“ç‚¹ä¹‹å‰æ’å…¥å…ƒç´  e
bool InsertPriorNode(LNode *p, ElemType e)
{
  if(p==NULL)
  {
    return false;
  }
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if( s == NULL )
  {
    return false;
  }
  s -> next = p -> next;
  p -> next = s;          //æ–°ç»“ç‚¹ s è¿åˆ° p ä¹‹å
  s -> next = p -> data;  //å°† p ä¸­çš„å…ƒç´ å¤åˆ¶åˆ° s ä¸­
  p -> data = e;          // p ä¸­çš„å…ƒç´ è¦†ç›–ä¸º e
  
  return true;
}
```
ç‰ˆæœ¬äºŒï¼ˆç‹é“ä¹¦ï¼‰
```C
//å‰æ’æ“ä½œï¼šåœ¨ p ç»“ç‚¹ä¹‹å‰æ’å…¥å…ƒç´  e
bool InsertPriorNode(LNode *p, LNode *s)
{
  if( p == NULL || s == NULL )
  {
    return false;
  }
  s -> next = p -> next;
  p -> next = s;          //æ–°ç»“ç‚¹ s è¿åˆ° p ä¹‹å
  
  ElemType temp = p -> data;    //äº¤æ¢æ•°æ®åŸŸéƒ¨åˆ†
  
  p -> data = s -> data;  
  s -> data = temp;          
  
  return true;
}
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

### 3. åˆ é™¤
#### 3.1 æŒ‰ä½åºåˆ é™¤
å¸¦å¤´ç»“ç‚¹
```C
bool ListDelete( LinkList &L, int i, ElemType &e )
{
  if( i<1 )
  {
    return false;
  }
  LNode *p;                   //æŒ‡é’ˆ p æŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=0;                    //
  p=L;                        // L æŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼Œä¸å­˜å‚¨æ•°æ®
  while( p!=NULL && j<i-1 )   //å¾ªç¯æ‰¾åˆ°ç¬¬ i-1 ä¸ªç»“ç‚¹
  {
    p = p -> next;
    j++;
  }
  if( p==NULL )               //å½“ i å€¼ä¸åˆæ³•æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€ 
  {
    return false;
  }
  if( p ->next==NULL )        //å½“ç¬¬ i-1 ä¸ªç»“ç‚¹æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€
  {
    return false;
  }
  LNode *q = p->next;         //ä»¤æŒ‡é’ˆ q æŒ‡å‘è¢«åˆ é™¤ç»“ç‚¹
  e = q->next;                //ç”¨æ•°æ®å…ƒç´  e è¿”å›åˆ é™¤å…ƒç´ çš„å€¼
  p->next = q->next;          //å°† *q æ‰€åœ¨ç»“ç‚¹ä»é“¾ä¸­æ–­å¼€
  free(q);                    //ç”¨ free å‡½æ•°é‡Šæ”¾å­˜å‚¨ç©ºé—´
  return true;                //è¿”å›æç¤ºâ€œæ“ä½œæˆåŠŸâ€
}

typedef struct LNode
{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

#### æ€è€ƒé¢˜ğŸ¤”ï¼š
  
ä¸å¸¦å¤´ç»“ç‚¹çš„æƒ…å†µä¸‹ï¼Œéœ€è¦å¯¹ç¬¬ä¸€ä¸ªå…ƒç´ ç‰¹æ®Šå¤„ç†å—ï¼Ÿ
  
ç­”ï¼šä¸éœ€è¦ï¼Œå› ä¸ºi=1æ—¶ï¼Œå¯ä»¥åŒ…å«åœ¨åç»­ `j<i-1` çš„æƒ…å†µé‡Œã€‚
```C
bool ListDelete( LinkList &L, int i, ElemType &e )
{
  if( i<1 )
  {
    return false;
  }
  LNode *p;                   //æŒ‡é’ˆ p æŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=0;                    //
  p=L;                        // L æŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼Œä¸å­˜å‚¨æ•°æ®
  while( p!=NULL && j<i-1 )   //å¾ªç¯æ‰¾åˆ°ç¬¬ i-1 ä¸ªç»“ç‚¹
  {
    p = p -> next;
    j++;
  }
  if( p==NULL )               //å½“ i å€¼ä¸åˆæ³•æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€ 
  {
    return false;
  }
  if( p ->next==NULL )        //å½“ç¬¬ i-1 ä¸ªç»“ç‚¹æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œè¿”å›æç¤ºâ€œé”™è¯¯â€
  {
    return false;
  }
  LNode *q = p->next;         //ä»¤æŒ‡é’ˆ q æŒ‡å‘è¢«åˆ é™¤ç»“ç‚¹
  e = q->next;                //ç”¨æ•°æ®å…ƒç´  e è¿”å›åˆ é™¤å…ƒç´ çš„å€¼
  p->next = q->next;          //å°† *q æ‰€åœ¨ç»“ç‚¹ä»é“¾ä¸­æ–­å¼€
  free(q);                    //ç”¨ free å‡½æ•°é‡Šæ”¾å­˜å‚¨ç©ºé—´
  return true;                //è¿”å›æç¤ºâ€œæ“ä½œæˆåŠŸâ€
}

typedef struct LNode
{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

#### 3.2 æŒ‡å®šç»“ç‚¹çš„åˆ é™¤
```C
//
bool DeleteNode( LNode *p )
{
  if( p==NULL )
  {
    return false;
  }
  LNode *q = p->next;       //ä»¤ q æŒ‡å‘ *p çš„åç»­ç»“ç‚¹
  p->data = p->next->data;  //å’Œåç»§ç»“ç‚¹äº¤æ¢æ•°æ®åŸŸ
  p->next = q->next;        //å°† *q ç»“ç‚¹ä»é“¾ä¸­æ–­å¼€
  free(q);                  //é‡Šæ”¾åç»§ç»“ç‚¹çš„å­˜å‚¨ç©ºé—´
  return true;
}
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

### 4. å»ºç«‹
#### 4.1 ä½¿ç”¨å°¾æ’æ³•å»ºç«‹å•é“¾è¡¨
```C
typedef struct LNode        //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
{
  ElemType data;            //æ¯ä¸ªç»“ç‚¹å­˜æ”¾ä¸€ä¸ªæ•°æ®å…ƒç´ 
  struct LNode *next;       //å®šä¹‰æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
}Lnode, *LinkList;

//åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„å•é“¾è¡¨ï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
bool InitList(LinkList &L)
{
  L = (LNode *)malloc(sizeof(LNode));     //ç”³è¯·ä¸€ç‰‡ç©ºé—´ç»™åˆ°å¤´ç»“ç‚¹
  if(L == NULL)
  {
    return false;                         //å†…å­˜ä¸è¶³ï¼Œåˆ†é…å¤±è´¥çš„è¯­å¥
  }
  L->next = NULL;                         //å¤´ç»“ç‚¹ä¹‹åæš‚æ—¶æ— ç»“ç‚¹
  return true;
}

void test()
{
  LinkList L;               //å£°æ˜ä¸€ä¸ªæŒ‡å‘å•é“¾è¡¨çš„æŒ‡é’ˆ
  InitList(L);              //åˆå§‹åŒ–ä¸€ä¸ªç©ºè¡¨
  //Â·Â·Â·åç»­ä»£ç Â·Â·Â·
}
```

```C
//åœ¨ç¬¬ i ä¸ªä½ç½®æ’å…¥å…ƒç´  e ï¼ˆå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ï¼‰
bool ListInsert(LinkList &L, int i, ElemType e)
{
  if(i<1)
  {
    return false;
  }
  LNode *p;       //æŒ‡é’ˆpæŒ‡å‘å½“å‰æ‰«æåˆ°çš„ç»“ç‚¹
  int j=0;        //å½“å‰pæŒ‡å‘çš„ç»“ç‚¹ä½ç½®
  p = L;          //LæŒ‡å‘å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹æ˜¯ç¬¬0ä¸ªç»“ç‚¹ï¼ˆä¸å­˜æ•°æ®ï¼‰
  while(p!=NULL && j<i-1)   //åˆ©ç”¨å¾ªç¯æ‰¾åˆ°æ‰€æŒ‡å®šçš„ç»“ç‚¹ï¼ˆi-1ï¼‰
  {
    p=p->next;
    j++;
  }
  if(p==NULL)    //å½“iå€¼ä¸åˆæ³•ç¨‹åºè¿”å›é”™è¯¯
  {
    return false;
  }
  LNode *s = (LNode *)malloc(sizeof(LNode));
  s->data = e;
  s->next = p->next;  //ä¸å¯å’Œä¸‹é¢äº¤æ¢ï¼
  p->next = s;        //å°†ç»“ç‚¹sè¿æ¥åˆ°pä¹‹å
  return true;
}
```
##### å°ç»“ï¼š
å°¾æ’æ³•å»ºç«‹å•é“¾è¡¨ï¼š
```
åˆå§‹åŒ–å•é“¾è¡¨ï¼›
è®¾ç½®å˜é‡ length è®°å½•é“¾è¡¨é•¿åº¦ï¼›
while å¾ªç¯{
      æ¯æ¬¡å–ä¸€ä¸ªæ•°æ®å…ƒç´  e;
      ListInsert(L, length+1,e)æ’åˆ°å°¾éƒ¨;
      length++;
}
```
ç‹é“ä¹¦ç‰ˆæœ¬ä»£ç 
```C
LinkList List_TailInsert(LinkList &L)
{
  int x;
  L = (LinkList)malloc(sizeof(LNode));    //åˆå§‹åŒ–ç©ºè¡¨
  LNode *s, *r=L;         // r ä¸ºè¡¨å°¾æŒ‡é’ˆ
  scanf("%d",&x);         //è¾“å…¥ç»“ç‚¹çš„å€¼
  while(x!=9999)          //ä»»æ„å®šä¹‰çš„ç»“æŸæ ‡è¯†
  {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = x;
    r->next = s;
    r = s;                // r æŒ‡å‘æ–°çš„è¡¨å°¾ç»“ç‚¹
    scanf("%d",&x);
  }
  r->next = NULLL;        //å°¾ç»“ç‚¹æŒ‡é’ˆç½®ç©º
  return L;
}
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

æ€è€ƒé¢˜ğŸ¤”ï¼šå¦‚æœä¸å¸¦å¤´èŠ‚ç‚¹çš„å•é“¾è¡¨ï¼Œå°¾æ’æ³•å¦‚ä½•å®ç°ï¼Ÿ

#### 4.2 ä½¿ç”¨å¤´æ’æ³•å»ºç«‹å•é“¾è¡¨
```C
LinkList Likst_HeadInsert(LinkList &L)      //é€†å‘å»ºç«‹å•é“¾è¡¨
{
  LNode *s; int x;
  L=(LinkList)malloc(sizeof(LNode));        //åˆ›ç«‹å¤´ç»“ç‚¹
  L->next=NULL;                             //åˆå§‹ä¸ºç©ºé“¾è¡¨->å¾ˆé‡è¦çš„æ“ä½œ
  scanf("%d",&x);                           //è¾“å…¥ç»“ç‚¹çš„å€¼
  while(x!=9999)                            //è¾“å…¥9999è¡¨ç¤ºç»“æŸ
  {
    s=(LNode *)malloc(sizeof(LNode));       //åˆ›å»ºæ–°ç»“ç‚¹
    s->data=x;
    s->next=L->next;
    L->next=s;                              //å°†æ–°ç»“ç‚¹æ’å…¥è¡¨ä¸­ï¼ŒLä¸ºå¤´æŒ‡é’ˆ
    scanf("%d",&x);
  }
  return L;
}
```

[è¿”å›é¡µé¦–](https://github.com/AdorableLake/hello-world/blob/master/Data%20Structure/2.3_LinkList.md#å•é“¾è¡¨linklist)

### 5. æŸ¥æ‰¾
#### 5.1 æŒ‰ä½æŸ¥æ‰¾
1. ç½‘è¯¾ç‰ˆæœ¬ä»£ç 
```C
LNode *GetElem(LinkList L, int i)
{
  if(i<0)
  {
    return NULL;
  }
  LNode *p;
  int j=0;
  p = L;
  while( p!=NULL && j<i )
  {
    p=p->next;
    j++;
  }
  return p;
}
```
2. ç‹é“ä¹¦ç‰ˆæœ¬ä»£ç 
```C
LNode *GetElem(LinkList L, int i)
{
  int j=1;
  LNode *p = L->next;
  if(i++0)
  {
    return L;
  }
  else if(i<1)
  {
    return NULL;
  }
  while( p!=NULL && j<i )
  {
    p=p->next;
    j++;
  }
  return p;
}
```

