## 单链表/LinkList
### 1. 定义
#### 1.1 使用代码定义一个单链表
```C
struct LNode            //定义单链表结点类型
{
  ElemType data;        //每个结点存放一个数据元素
  struct LNode *next;   //指针指向下一个结点
};

//增加一个新的结点：在内存中申请一个结点所需的空间，并用指针 P 指向这个结点
struct LNode *p=(struct LNode *)malloc(sizeof(struct LNode));

//typedef 关键字--数据类型重命名
typedef<ElemType><para>

/*
e.g:
typedef int zhengshu;
typedef int *zhengshuzhizhen;
int x = 1;  <==>  zhengshu x = 1;
int *p;     <==>  zhengshuzhizhen p;
*/
```
以下两段代码表示的意思一致👇

```C

//1
struct LNode                                                      
{
  ElemType data;                                                  
  struct LNode *next;   
};
typedef struct LNode LNode;
typedef struct LNode *LinkList;

//2
typedef struct LNode
{
  ElemType data;
  struct Lnode *next;
}Lnode, *LinkList;
```

🌰

```C

typedef struct LNode        //定义单链表结点类型
{
  ElemType data;            //每个结点存放一个数据元素
  struct LNode *next;       //定义指针指向下一个结点
}Lnode, *LinkList;

Lnode *GetElem(LinkList l, int i)   
//语句开始使用 LNode * 表示墙敲返回的是一个结点，按位查找语句使用 LinkList 表示强调这是一个单链表
{
  int j=1;
  LNode *p=L->next;
  if(i==0)
  {
    return L;
  }
  else if(i<1)
  {
    return NULL;
  }
  while(p!=NULL && j<1)
  {
    p=p->next;
    j++;
  }
  return p;
}
```
### 1.2 使用头插法建立单链表
```C
LinkList Likst_HeadInsert(LinkList &L)      //逆向建立单链表
{
  LNode *s; int x;
  L=(LinkList)malloc(sizeof(LNode));        //创立头结点
  L->next=NULL;                             //初始为空链表
  scanf("%d",&x);                           //输入结点的值
  while(x!=9999)                            //输入9999表示结束
  {
    s=(LNode *)malloc(sizeof(LNode));       //创建新结点
    s->data=x;
    s->next=L->next;
    L->next=s;                              //将新结点插入表中，L为头指针
    scanf("%d",&x);
  }
  return L;
}
```
### 1.3 不带头节点的单链表
```C
typedef struct LNode        //定义单链表结点类型
{
  ElemType data;            //每个结点存放一个数据元素
  struct LNode *next;       //定义指针指向下一个结点
}Lnode, *LinkList;

//初始化一个空的单链表
bool InitList(LinkList &L)
{
  L=NULL;
  return true;
}

void test()
{
  LinkList L;               //声明一个指向单链表的指针
  
  InitList(L);              //初始化一个空表
  //···后续代码···
}

bool Empty(LinkList L)      //判空操作
{
  if(L == NULL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

//or

bool Empty(LinkList L)
{
  return (L == NULL);
}
```

#### 1.4 带头结点的单链表
```C
typedef struct LNode        //定义单链表结点类型
{
  ElemType data;            //每个结点存放一个数据元素
  struct LNode *next;       //定义指针指向下一个结点
}Lnode, *LinkList;

//初始化一个空的单链表（带头结点）
bool InitList(LinkList &L)
{
  L = (LNode *)malloc(sizeof(LNode));     //申请一片空间给到头结点
  if(L == NULL)
  {
    return false;                         //内存不足，分配失败的语句
  }
  L->next=NULL;                           //头结点之后暂时无结点
  return true;
}

void test()
{
  LinkList L;               //声明一个指向单链表的指针
  InitList(L);              //初始化一个空表
  //···后续代码···
}

bool Empty(LinkList L)      //判空操作
{
  if(L -> next == NULL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

//or

bool Empty(LinkList L)
{
  return (L == NULL);
}
```
### 按位序插入（带头节点）
```C
bool ListInsert(LinkList &L, int i, ElemType e)
{
  
}
