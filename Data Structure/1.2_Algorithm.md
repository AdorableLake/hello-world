## 算法的时间复杂度
e.g 1: 逐步递增性爱你（“爱你三千遍”）
```C
#include<stdio.h>

void LoveYou(int n)
{
  int i=1;
  while(i<=n)
  {
    i++;
    printf("I Love You %d.\n",i);
  }
  printf("I Love You More Than %d.\n",n);
}

int main()
{
  loveYou(3000);
  
  return 0;
}

//T(n)=3*n+3=O(n)
```
e.g 2：嵌套循环型爱你
```C
#include<stdio.h>

void LoveYou(int n)
{
  int i=1;
  while(i<=n) // T1(n)=O(n)
  {
    i++;
    printf("I Love You %d.\n",i);
    for(int j=1; j<=n; j++)
    {
      printf("I am Iron Man.\n");// T2(n)=O(n^2)
    }
  }
  printf("I Love You More Than %d.\n",n);
}

int main()
{
  loveYou(3000);
  
  return 0;
}

//T(n)=O(n^2)
//嵌套循环只需考虑最内层循环
```
e.g 3：指数递增型爱你
```C
#include<stdio.h>

void LoveYou(int n)
{
  int i=1;
  while(i<=n) // T1(n)=O(n)
  {
    i=i*2;
    printf("I Love You %d.\n",i);
  }
  printf("I Love You More Than %d.\n",n);
}

int main()
{
  loveYou(3000);
  
  return 0;
}

//T(n)=O(log_2n)

```
e.g 4：搜索数字型爱你
```C
#include<stdio.h>

void LoveYou(int flag[], int n)
{
  printf("I am Iron Man.\n");
  for(int i=0; i<=n; i++)  
  {
    if(flag[i]==n)
    {
      printf("I Love You %d.\n",n);
      break;
    }
  }
}

int main()
{
  int flag[n]={1...n};// flag 数组中乱序存放了 1～n 这些数
  loveYou(flag,n);
  
  return 0;
}

//1<=T(n)<=n
//T(n)best=O(1)
//T(n)worst=O(n)  ->*
//T(n)averge=O(n*(n+1)/2) ->*
```
## 算法的空间复杂度
