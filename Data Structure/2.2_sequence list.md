## SequenceList/顺序表
### 1. 静态分配
```
#define MaxSize 50          //定义线性表的最大长度
typedef struct
{
  ElemType data[MaxSize];   //顺序表的元素
  int length;               //顺序表的当前长度
}SqList;                    //顺序表的类型定义
```
#### e.g 1: “脏数据”

```C
#include<stdio.h>
#define MaxSize 10    //定义最大长度
typedef struct  
{
  int data[MaxSize];  //用静态数组存放数据元素
  int length;         //顺序表的当前长度
}SqList;              //顺序表的类型定义

//基本操作：初始化一个顺序表
void InitList(SqList &L)
{
  /*
  for(int i=0; i<MaxSize; i++)
  {
    L.data[i]=0;      //将所有数据元素设置为默认初始值
  }
  */
  L.length=0;         //顺序表初始长度为0
}

int main()
{
  SqList L;
  InitList(L);
  //尝试“违规打印”整个数组
  for(int i=0; i<MaxSize; i++)
  {
    printf("data[%d]=%d\n",i,L.data[i]);
  }
}
```
#### 1.1 静态分配的缺点：
1. 数组大小和空间事先已经被定义，无法被更改；
2. 定义过大会造成资源浪费，定义过小容易造成内存溢出；

### 2. 动态分配
```
#define InitSize 100
typedef struct
{
  ElemType *data;
  int MaxSize;
  int length;
}SeqList;
```

#### 2.1 ``malloc``与``free``
C语言的初始动态分配语句
```
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
```
#### e.g 2: 动态分配的例子🌰
  
```C
#include<stdlib.h>
#define InitSize 10   //默认的最大长度为 10
typedef struct
{
  int *data;          //指示动态分配数组的指针
  int MaxSize;        //定义顺序表的最大容量
  int length;         //定义顺序表的当前长度
}SeqList;

void InitList(SeqList &L)
{
  //使用 malloc 函数申请一片连续的存储空间
  L.data=(int *)malloc(InitSize*sizeof(int));
  L.length=0;
  L.MaxSize=InitSize;
}

//增加动态数组的长度
void IncreaseSize(SeqList &L, int len)
{
  int *p=L.data;
  //使用 malloc 函数申请一片连续的存储空间已满足当前与欲增加的数据元素
  L.data=(int *)malloc((L.MaxSize+len)*sizeof(int));    
  for(int i=0; i<L.length; i++)
  {
    L.data[i]=p[i];         //将数据复制到新区域
  }
  L.MaxSize=L.MaxSize+len;  //顺序表最大长度增加 len
  free(p);                  //释放原来的内存空间
}

int main()
{
  SeqList L;                //声明一个顺序表 L
  InitList(L);              //初始化顺序表 L
  //···往顺序表中插入若干个元素···
  IncreseSize(L,5);
  return 0;
}
```
